第k大问题――可持久化线段树的应用 By strongoier

关于各数据结构的使用请自行参考资料，可持久化数据结构推荐陈立杰的《可持久化数据结构研究》。

【例1】SPOJ MKTHNUM：区间第k大数问题（无修改，在线询问）

算法一：使用二分 + 归并树，时间复杂度O(Nlog^3N)。

算法二：使用可持久化线段树/划分树，时间复杂度O(NlogN)。

【例2】BZOJ 1901 Dynamic Rankings：区间第k大数问题（有修改，在线询问）

算法一：使用二分 + 线段树套平衡树，时间复杂度O(Nlog^3N)。

算法二：使用树状数组套可持久化线段树，时间复杂度O(Nlog^2N)。

根据可持久化线段树的一般定义，我们用T_i表示加入a_1, a_2, ..., a_i后形成的权值线段树，那么它可以通过T_(i - 1)插入a_i得到。

令A_i表示仅加入a_i形成的权值线段树，由于权值线段树支持加法，那么我们完全可以把这些权值线段树看作一维结构。

假如没有修改操作，我们用T_i表示A_1, A_2, ..., A_i的和，即前缀和，T_i = T_(i - 1) + A_i。那么用T_r - T_(l - 1)就可以得到区间[l, r]的权值线段树。

假如有修改操作，就如动态维护数组的部分和一样，静态的前缀和数组是不行的，因此我们考虑使用树状数组维护，T_i表示的范围等同于树状数组里的S_i，即每一次修改A_i都要对logN棵T_i进行修改。

【例3】BZOJ 3110 K大数查询：区间第k大数问题（有同位置插入，在线询问）

考虑使用可持久化线段树来解决这个问题，A_i表示位置i上的权值线段树，对于A_a, A_a + 1, ..., A_b，操作1即都插入c，操作2即查询其中第K大值。

对于查询区间的操作，我们知道，令S_i = A_1 + A_2 + ... + A_i，那么查询区间[a, b]即在权值线段树上S_b - S_(a - 1)上查询第K大值。

由于是修改区间，我们考虑作差来完成区间修改转化为单点修改，令D_i = A_i - A_(i - 1)，那么S_i = D_1 * i + (D_2 - D_1) * (i - 1) + (D_3 - D_2) * (i - 2) + ... + D_i，即S_i = sum{D_k * (i - k + 1)}(1 <= k <= i)。

对于某个确定的i，我们只要知道sum{D_k}(1 <= k <= i}和sum{D_k * k}(1 <= k <= i}，那么很容易想到用树状数组来维护这两个和，而且修改只需要对两个端点进行。

时间复杂度O(Nlog^2N)。

【例4】SPOJ COT：路径第k大数问题（无修改，在线询问）

我们用T_i表示加入根到i路径上的数形成的权值线段树，那么它可以通过T_father(i)插入a_i得到。易得，路径u -> v上的数形成的权值线段树T = T_u + T_v - T_LCA(u, v) - T_father(LCA(u, v))，再查询第k大即可。

其中LCA可以使用倍增算法实现，需要注意的是，上述插入a_i的顺序也要按照DFS序。整体时间复杂度为O(NlogN)。

【例5】CF 191E Thwarting Demonstrations：第k大子段和问题（无修改，单询问）

直接求明显是不现实的，因此我们想到二分答案C再进行验证，大于等于C的数大于等于K个的最大的C即为答案。

下面要考虑的问题就是如何求大于等于C的数的个数。由于是针对所有子段，我们很容易想到要枚举子段的右端点。

考虑部分和s_0, s_1, ..., s_N，对于右端点i，我们只要知道在s_0, s_1, ..., s_(i - 1)里小于等于s_i - C的数的个数即可。

这样的话，就变成一个用高级数据结构来维护的问题了。

转化问题一：不断查询a_i, a_(i + 1), ..., a_j里小于等于C的数的个数。那么显然可以离散化后用可持久化线段树来维护。

转化问题二：依次查询a_1，a_2, ..., a_(i - 1)里小于等于C的数的个数，并插入a_i。那么这样可以直接用平衡树来维护，或者离散化后用树状数组来维护。

以上方法的时间复杂度均为O(Nlog^2N)。

第k大问题 By strongoier

关于各数据结构的使用请自行参考资料，可持久化数据结构推荐陈立杰的《可持久化数据结构研究》。

【例1】SPOJ MKTHNUM：区间第k大数问题（无修改，在线询问）

算法一：使用二分 + 归并树，时间复杂度O(Nlog^3N)。

算法二：使用可持久化线段树/划分树，时间复杂度O(NlogN)。

【例2】BZOJ 1901 Dynamic Rankings：区间第k大数问题（有修改，在线询问）

算法一：使用二分 + 线段树套平衡树，时间复杂度O(Nlog^3N)。

算法二：使用树状数组套可持久化线段树，时间复杂度O(Nlog^2N)。

根据可持久化线段树的一般定义，我们用T_i表示加入a_1, a_2, ..., a_i后形成的权值线段树，那么它可以通过T_(i - 1)插入a_i得到。

令A_i表示仅加入a_i形成的权值线段树，由于权值线段树支持加法，那么我们完全可以把这些权值线段树看作一维结构。

假如没有修改操作，我们用T_i表示A_1, A_2, ..., A_i的和，即前缀和，T_i = T_(i - 1) + A_i。那么用T_r - T_(l - 1)就可以得到区间[l, r]的权值线段树。

假如有修改操作，就如动态维护数组的部分和一样，静态的前缀和数组是不行的，因此我们考虑使用树状数组维护，T_i表示的范围等同于树状数组里的S_i，即每一次修改A_i都要对logN棵T_i进行修改。

【例3】SPOJ COT：路径第k大数问题（无修改，在线询问）

我们用T_i表示加入根到i路径上的数形成的权值线段树，那么它可以通过T_father(i)插入a_i得到。易得，路径u -> v上的数形成的权值线段树T = T_u + T_v - T_LCA(u, v) - T_father(LCA(u, v))，再查询第k大即可。

其中LCA可以使用倍增算法实现，需要注意的是，上述插入a_i的顺序也要按照DFS序。整体时间复杂度为O(NlogN)。

【例4】CF 191E Thwarting Demonstrations：第k大子段和问题（无修改，单询问）

直接求明显是不现实的，因此我们想到二分答案C再进行验证，大于等于C的数大于等于K个的最大的C即为答案。

下面要考虑的问题就是如何求大于等于C的数的个数。由于是针对所有子段，我们很容易想到要枚举子段的右端点。

考虑部分和s_0, s_1, ..., s_N，对于右端点i，我们只要知道在s_0, s_1, ..., s_(i - 1)里小于等于s_i - C的数的个数即可。

这样的话，就变成一个用高级数据结构来维护的问题了。

转化问题一：不断查询a_i, a_(i + 1), ..., a_j里小于等于C的数的个数。那么显然可以离散化后用可持久化线段树来维护。

转化问题二：依次查询a_1，a_2, ..., a_(i - 1)里小于等于C的数的个数，并插入a_i。那么这样可以直接用平衡树来维护，或者离散化后用树状数组来维护。

以上方法的时间复杂度均为O(Nlog^2N)。

Manacher By strongoier

学习算法原理参见http://www.felix021.com/blog/read.php?2040。

【例1】POJ 3974 Palindrome

题目大意：

给出一个长度为N(1 <= N <= 1000000)的字符串，求最长回文子串的长度。

算法分析：

直接使用Manacher算法，时间复杂度O(N)。

【例2】BZOJ 2565 最长双回文串

题目大意：

给出一个长度为N(2 <= N <= 100000)的字符串，求最长双回文子串T的长度，即可将T分为非空连续两部分X, Y，且X和Y都是回文串。

算法分析：

首先我们用Manacher算法预处理出以i为起点的最长回文半径。

考虑枚举分界点i，我们要使得以i为右边界、左边界的回文子串都最长，也就是要分别找到在i左右两侧离i最远的回文半径可覆盖至i的点。

那么，以找左侧点为例，我们从左往右扫描，同时维护一个当前处理到的右边界。假设点i的最长回文半径为r，那么我们只要更新从当前右边界到i + r这段范围里的，同时更新右边界为i + r。

其正确性是显然的，因为左右两点如果同时覆盖到一个位置，那么选左边那个必然是更优的。找右侧点同理。时间复杂度O(N)。

【例3】BZOJ 2160 拉拉队排练

题目大意：

给出一个长度为N(1 <= N <= 1000000)的字符串，求将所有长度为奇数的回文子串按长度降序排序后，前K个长度的乘积。

算法分析：

首先我们用Manacher算法预处理出以i为起点的最长回文半径。我们发现，长度不超过N种。因此，我们可以很容易地利用区间统计出每种长度的个数。

接下来从高到低取前k个，每次使用快速幂即可。时间复杂度O(NlogN)。

【例4】BZOJ 2342 双倍回文

题目大意：

记字符串w的倒置为r(w)，若w = r(w)，则称w回文。若x = wr(w)wr(w)，则称x双倍回文。求长度为N(1 <= N <= 500000)的字符串的最长双倍回文子串。

算法分析：

首先我们用Manacher算法预处理出以i为起点的最长回文半径。枚举中轴i，我们需要找到最小的子中轴j(j < i)，使得j的最长回文半径能覆盖到i，并且i到j的距离的2倍不能超过i的最长回文半径。

由i的最长回文半径，我们可以很容易得到“i到j的距离的2倍不能超过i的最长回文半径”的j的左边界k。那么，我们要找的就是在k右侧离k最近的最长回文半径能覆盖到i的j。

我们很容易想到用并查集维护这个右侧最近值，当求的最近值不能覆盖到i就把最近值右移（因为这个最近值不可能再被更大的i所用）。

由于每个点最多被删一次，查询的有效点最多也只有N个，再加上并查集的时间复杂度，整体时间复杂度O(NlogN)。

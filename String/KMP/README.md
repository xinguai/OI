KMP By strongoier

学习算法原理参见http://www.matrix67.com/blog/archives/115。

一、p数组性质

【例1】POJ 2752 Seek the Name, Seek the Fame

题目大意：

给出一个长度为N(1 <= N <= 400000)的字符串，找出所有可能的长度相同的前缀和后缀。

算法分析：

根据KMP自匹配中p数组的定义，我们发现答案就是p[N], p[p[N]], ...。时间复杂度O(N)。

【例2】HDOJ 3336 Count the string

题目大意：

给出一个长度为N(1 <= N <= 200000)的字符串，求这个字符串的每个前缀在整个字符串里出现次数的和。

算法分析：

考虑枚举i，则要求以i为结尾的子串有多少个是前缀，也就是s[1..i]有多少个后缀是这个字符串的前缀。

我们知道，通过KMP算法求出的p[i]表示s[1..i]和这个字符串前缀的最长匹配长度，它应当被计入答案，同理，p[p[i]], p[p[p[i]]], ...对应的前缀也都应计入答案。

为加速计算，我们很容易得到递推式f[i] = f[p[i]] + 1。时间复杂度O(N)。

【例3】POJ 3461 Oulipo

题目大意：

给出字符串W(1 <= |W| <= 10000)和字符串T(1 <= |T| <= 1000000)，找出W在T中出现的次数。

算法分析：

直接使用KMP算法即可，时间复杂度O(|W| + |T|)。

【例4】BZOJ 1009 GT考试

题目大意：

准考证号为N(1 <= N <= 10^9)位0~9的数，给出长度为M(1 <= M <= 20)的不吉利数段，求不包含不吉利数段的准考证号个数。

算法分析：

对于不吉利数段，我们可以利用p数组预处理出在第i位后接j之后的最长匹配位置nxt[i][j]。

为了记录当前匹配的状态，我们用f[i][j]表示到准考证号第i位，匹配到不吉利数段第j位的方案数，那么枚举在后一位添加的数字k，显然可以转移到f[i + 1][nxt[j][k]]（若nxt[j][k]为M则不能转移）。

由于N很大，我们可以使用矩阵乘法 + 快速幂来加速计算。时间复杂度O(M^3logN)。

二、覆盖子串问题

【例1】POJ 2406 Power Strings

题目大意：

一个字符串A(1 <= |A| <= 1000000)可以写成某一个子串B重复N次所得，记为A = B^N，求最大的N。

算法分析：

令L = |A|，容易发现，用KMP自匹配后L - p[L]即得到最小覆盖子串的长度。

下面我们要证明一个问题：一个字符串的覆盖子串长度，一定是它的最小覆盖子串长度的倍数。

设最小覆盖子串长度d整除L, 假设存在u > d满足u整除L且d不整除u。

易得，A_i = A_(i + d)，A_i = A_(i + u)，则A_(i + d) = A_(i + u)，即A_i = A_(i + u - d)，不断进行可得到A_i = A(i + u - kd)（k为正整数）。

因为d不整除u，那么必然存在k使得0 < u - kd < d，与d是最小循环子串长度矛盾。

所以，最小覆盖子串长度若为L的约数则得解否则输出1。时间复杂度O(L)。

【例2】POJ 2185 Milking Grid

题目大意：

给出R * C(1 <= R <= 10000, 1 <= C <= 75)的矩阵，求一个最小子矩阵使得其横向纵向各重复无限次后能覆盖原矩阵。

算法分析：

由于不要求恰好覆盖（即子矩阵长宽不一定整除原矩阵长宽），我们需要求出每一行、每一列的覆盖子串及其倍数，再分别取最小的公共值相乘即可。

那么，以每一行的覆盖子串为例，其长度其实就是L, L - p[L], L - p[p[L]], ...，用KMP可以很方便解决。时间复杂度O(RC(logR + logC))。

三、修改比较函数

【例】POJ 3167 Cow Patterns

题目大意：

给出N(1 <= N <= 100000)头排成一列的奶牛的身高（范围1..S）和长度为K的捣乱身高趋势，求出这个队伍里有多少个子列满足捣乱身高趋势。

趋势相同指：对于每头奶牛，其身高排名都相等。

算法分析：

由于是个匹配问题，我们考虑KMP。若在两个序列a, b里对应位置的x, y排位相同，即a中小于x的个数和小于等于x的个数与b中小于y的个数和小于等于y的个数相等。

因此，我们只要将KMP的比较函数从相等修改为趋势相同（描述如上），保证每一位的排位均相等，则匹配成功。为了动态维护这个排位，我们用树状数组来维护小于、小于等于某个数的个数。时间复杂度O((N + K)logS)。

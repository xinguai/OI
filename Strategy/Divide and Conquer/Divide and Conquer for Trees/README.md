树的点分治 By strongoier

处理此类树上满足某要求的路径问题，通常采用点分治的方法。

而对于每次处理过根路径的常用方法通过以下例题来呈现。

【例1】POJ 1741 Tree

题目大意：

给出N(1 <= N <= 10000)个结点的树，求使得路径u -> v长度不超过k的点对(u, v)的个数。

算法分析：

首先我们对这棵树进行点分治，接下来考虑处理以root为根的子树。

记d[x]为x到root的距离，那么我们把子树的所有结点的d拉出来，即转化为了a[x] + a[y] <= k的(x, y)对数，这是可以通过排序后扫一遍解决的。

然后，这样可能出现重复的情况（x, y在root的同一儿子内部），那么我们只需要再对root的每个儿子进行同样的操作，但是是从之前的答案中减去。

时间复杂度O(Nlog^2N)。

【例2】BZOJ 2599 Race

题目大意：

给出N(1 <= N <= 200000)个结点的树，求长度等于K(1 <= K <= 1000000)的路径的最小边数。

算法分析：

首先我们对这棵树进行点分治，接下来考虑处理以root为根的子树。

为了方便，我们把更新答案和更新状态分离开。用d[i]表示长度为i的路径的最小边数。

当我们枚举root的某个儿子时，我们需要利用的是之前的儿子的d和当前路径长度合并从而更新答案。

做完以后，我们在把这个儿子路径上的状态更新到d中，从而在以后更新别人。

时间复杂度O(NlogN)。

【例3】SPOJ FTOUR2

题目大意：

给出N(1 <= N <= 200000)个结点的树，其中有M个是黑结点，求包含不超过K个黑点的路径的最长长度。

算法分析：

首先我们对这棵树进行点分治，接下来考虑处理以root为根的子树。

倘若我们仍采用上一题的方法更新答案，由于更新的是一个区间，其状态总量是非常大的。

那么，我们考虑把root的儿子按路径上最多黑结点个数从大到小排序，用b[i](0 <= i <= K)表示过root的包含不超过i个黑结点的路径的最长长度。

设从某个儿子走下去路径最多黑结点个数为R，则我们用a[i](0 <= i <= R)表示从这个儿子走下去路径上有i个黑结点的最长长度。

注意更新的时候需要考虑[0, R]和[K - R, K]相交的情况。

第一步考虑利用之前的b和当前的a更新答案，即a[i] + b[K - i](0 <= i <= R)。

第二步考虑利用当前的a来更新b，我们发现，由于保证了R的单调减，需要更新的b的元素个数最多为R（再多以后的第一步不可能用到），因此我们只要更新b[i](K - R <= i <= K)即可。

分析复杂度，枚举每个儿子时，其R必然小于等于这个儿子的大小，因此对a, b的更新过程必然不超过以root为根的子树的总结点数。

因此，更新的总复杂度为O(NlogN)。此外，每个点最多在一次排序中，其复杂度仍为O(NlogN)。综上，算法整体时间复杂度O(NlogN)。

【例4】BZOJ 1758 重建计划

题目大意：

给出N(1 <= N <= 100000)个结点的树，求边数属于[L, U]的路径中路径长度除以边数的最大值。

算法分析：

首先我们对这棵树进行点分治，接下来考虑处理以root为根的子树。

由于求的是比值，我们很容易想到解决分数规划问题的一般思路――二分。

二分以后我们把边重赋权，然后求边数属于[L, U]的最长路径再判断即可。

这里可以借鉴上一题的思路，同样是排序来做，但更新答案不再是直接一路取max，而是使用单调队列来更新这个类似移动窗口的问题。

要注意的是，初值不能全设为负无穷，长度为0的路径是初始存在的（即直接以root为起点走下去）。

由于有二分，时间复杂度O(Nlog^2N)。
